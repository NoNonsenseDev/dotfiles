#!/usr/bin/env bash

set -euo pipefail

usage() {
  echo "Usage: $0 -s SEARCH -r REPLACE [-d DIRECTORY]"
  echo "Options:"
  echo "  -s SEARCH     Search string"
  echo "  -r REPLACE    Replacement string"
  echo "  -d DIRECTORY  Directory to search in (default: current directory)"
  exit 1
}

# Initialize variables
SEARCH=""
REPLACE=""
DIRECTORY="."

# Parse command line options
while getopts ":s:r:d:" opt; do
  case $opt in
    s) SEARCH="$OPTARG" ;;
    r) REPLACE="$OPTARG" ;;
    d) DIRECTORY="$OPTARG" ;;
    \?) echo "Invalid option: -$OPTARG" >&2; usage ;;
    :) echo "Option -$OPTARG requires an argument" >&2; usage ;;
  esac
done

# Validate required arguments
if [ -z "$SEARCH" ] || [ -z "$REPLACE" ]; then
  echo "Error: -s SEARCH and -r REPLACE are required" >&2
  usage
fi

# Validate directory exists
if [ ! -d "$DIRECTORY" ]; then
  echo "Error: Directory '$DIRECTORY' does not exist" >&2
  exit 1
fi

echo "Found occurrences:"
mapfile -t SEARCH_RESULTS < <(rg -s "${SEARCH}" --vimgrep "$DIRECTORY" || {
  echo "No matches found."
  exit 0
})

printf '%s\n' "${SEARCH_RESULTS[@]}"

# Extract unique files from the search results
mapfile -t MATCHED_FILES < <(printf '%s\n' "${SEARCH_RESULTS[@]}" | cut -d':' -f1 | sort -u)

# Ask for global replacement
read -r -p "Replace all occurrences? (y/N) " response
if [[ "$response" =~ ^[Yy]$ ]]; then
  for file in "${MATCHED_FILES[@]}"; do
    echo "Replacing in: $file"
    rg -s "${SEARCH}" -r "${REPLACE}" "$file" | sponge "$file"
  done
  exit 0
fi

# Handle files individually
for file in "${MATCHED_FILES[@]}"; do
  echo -e "\nOccurrences in: $file"
  grep -F "${file}" <(printf '%s\n' "${SEARCH_RESULTS[@]}")

  read -r -p "Replace occurrences in this file? (y/N) " response
  if [[ "$response" =~ ^[Yy]$ ]]; then
    rg -s "${SEARCH}" -r "${REPLACE}" "$file" | sponge "$file"
    echo "Replaced in: $file"
  fi
done
